---
title: GLMMs with Cersei Lannister
author: ~
date: '2016-09-15'
slug: glmms-with-cersei-lannister
categories: ["Statistics"]
tags: ["R", "GLMM"]
---

_I wrote this a long time ago while preparing for job interviews. Though I've made some stylistic changes, the analysis is as it was when I first published it on a previous blog. In other words, nothing in this post relates to my current projects at Google, nor were any Google data used or consulted: it was written over a year before my start date. All methods and applications covered are commonplace, and are discussed widely and publicly._

------

This post does the following:

1) Gives accessible examples of fitting mixed-effects models in **R**
2) Discusses the interpretation of and motivation for mixed effects regression models
3) Provides short, educational GOT fan-fic, with pictures

Some of this is in response to a [great article](http://www.unofficialgoogledatascience.com/2016/03/using-random-effects-models-in.html) from folks at Google. They show a cool result about the predictive efficacy of a mixed-effects model, so I decided to try a related experiment. I found their interpretation of the model somewhat off, particularly in distinguishing it from a Bayesian approach. So I'll be expanding on that as well.

Some code is in-line, but not all of it. The code provided is associated with the **R** library chosen to fit the mixed models, called `lme4`, and is meant to display its basic functionality. The rest of the code is available upon request.

Hat tip to [this neat tool](http://fantasynamegenerators.com/got-westeros-names.php#.V8RQeSgrKUk) providing endless Westeros-style names to use for the first story. That story covers what it means to have different experimental units in a regression model. This is an important concept for understanding why we might want to use a mixed-model in the first place. Enter the Lannister family:

# Jaime's archers

```{r, echo = FALSE, message = FALSE}
require(lme4)
require(ggplot2)
require(gridExtra)

# Population of archer effects
set.seed(12345)
sig_a <- 20
pop_size <- 1000
m_pop <- rnorm(pop_size, 0, sig_a)

# Loading Westeros names!
wnames <- unlist(readLines("male_westeros_names.txt"))

# archer data function
make_archer_data <- function (population, p, n, mu, sig_e, tau, shots = NULL) {
  
  # Preparing number of shots
  if (is.null(shots)) {
    shots <- rep(n * 2, p)
  }
  
  # Sample data
  r_pop <- sample(population, p)
  theta <- c(mu, tau, r_pop)
  intercept <- rep(1, sum(shots))
  bow <- unlist(lapply(shots, function (m) c(rep(1, m / 2), rep(0, m / 2))))
  m_mat <- diag(p)[rep(1:p, shots), ]
  X <- cbind(intercept, bow, m_mat)
  Y <- X %*% theta + rnorm(sum(shots), 0, sig_e)
  
  # Return data
  names <- sample(wnames, p)
  name_data <- rep(names, shots)
  bow_data <- unlist(lapply(shots, function (m) c(rep("Northwood", m / 2), rep("Southwood", m / 2))))
  dataMat <- data.frame("Distance_" = Y,
                        "Bow_" = bow_data,
                        "Name_" = name_data)
  effects <- r_pop
  names(effects) <- names
  return(list("Data" = dataMat, "Effects" = effects))
  
}

set.seed(1)
JaimeExp1 <- make_archer_data(m_pop, 3, 10, 150, 5, 10)
lme1 <- lmer(Distance_ ~ Bow_ + (1 | Name_), data = JaimeExp1$Data)
set.seed(2)
JaimeExp2 <- make_archer_data(m_pop, 50, 10, 150, 5, 10)
set.seed(3)
n.shots <- 2 * rpois(50, 5)
set.seed(3)
JaimeExp3 <- make_archer_data(m_pop, 50, 10, 150, 5, 10, shots = n.shots)
```

Jaime was preparing for a long journey, on official Lannister business. Knowing that things would likely come to swords, he assembled a small force to accompany him. He had some time to take special care outfitting his troops, so he decided to run an experiment with two different kinds of bows.

Normally, Lannister forces used bows made from Northwood, as common knowledge said they are stronger than Southwood bows. However, since Jaime is a Southerner, he preferred Southwood bows out of pride and convenience. He wanted to see if use of Southwood bows cause a statistically significant difference in archer range.

So, he chose three archers randomly from the kingdom's forces, who each would shoot a Northwood bow and a Southwood bow 10 times. He bullied some local city-folk into measuring and recording the distance of the shots, in meters. Some of the resulting data is shown below:

```{r, echo = FALSE}
print(head(JaimeExp1$Data), digits = 2)
```

The other two archers were named Fabiar Darklyn and Margan Drumm. Jaime fit the following linear regression model to his experiment's data:
\[
Y_{ik} = \mu + \tau\mathbb{1}(i = 2) + \epsilon_{ik}
\]
In that equation, $Y_{ik}$ is the $k$-th shot from bow $i = 1,2$, and the Southwood bow is considered to be the second bow. The variables $\mu$ and $\tau$ represent the mean shot distance and mean effect of the Southwood bow. The final term $\epsilon_{ik}$ is the random error (the Winds of Westeros, perhaps) contributing to the $k$-th shot from the $i$-th bow. There are $3\times 10 = 30$ shots per bow, since each marksman shoots each bow 10 times. The errors are independent shot-to-shot and Normally distributed with constant variance $\sigma^2_e$. Here's the summary of Jaime's analysis:

```{r}
lm0 <- lm(Distance_ ~ Bow_, data = JaimeExp1$Data)
summary(lm0)
```

When the archers switched to a Southwood bow, their shot distances decreased by about 10 meters, on average. However, Jaime realized his p-value was not below that magical 0.05 threshold! He strutted merrily out of the experiment grounds, confident that his results must be due to unfair winds. (Clearly, Jaime missed some important Statistical Lectures of the Crown.)

![*"A Lannister always pays attention to statistical differences in bow types"*](jaime.jpg)

## Adding archer terms

He was, of course, stopped by his brother Tyrion, who said "now Jaime, can't you see that you chose archers of wildly different statures? Only a fool would not account for this in his analysis." Grumpily, Jaime re-fit his model with additional terms for the archers:

\[
Y_{ijk} = \mu + \tau\mathbb{1}(i = 2) + \alpha_j + \epsilon_{ik}
\]

Here, $Y_{ijk}$ is the $k$-th shot (now $k$ goes from 1 to 10) from the $j$-th archer using the $i$-th bow. The $\alpha_j$ parameters represent archer $j$'s baseline skill. Here were Jaime's results with the new model:


```{r}
lm1 <- lm(Distance_ ~ Bow_ + Name_, data = JaimeExp1$Data)
summary(lm1)
```

After accounting for the different archer, the estimated effect of the Southwood bow became quite statistically significant. These results weren't as pleasing to Jaime, who stormed past a smirking Tyrion. "Well? What read your results?" he heard as he slammed the training field gate behind him.

So what happened? There were two separable sources of error around the bow effect: per-shot random error, and variance among archer shooting strengths. At Tyrion's suggestion, Jaime controlled for this in the second model by including archer effects.

![*"I drink, and I account for variance in experimental units"*](tyrion.png)

Here's an illustration of why it's important to include archer effects, or in general, "experimental unit" effects. Without knowledge of the particular archer, Jaime's data look like this:

```{r, echo = FALSE}
rorder <- sample(1:nrow(JaimeExp1$Data))
bowData1 <- JaimeExp1$Data[rorder, ]
bowData1 <- cbind("Location" = 1:nrow(bowData1), bowData1)
p <- ggplot(bowData1, aes(Location, Distance_)) + 
  geom_point(aes(colour = Bow_), size = 3) + 
  ggtitle("Bird's-Eye of Shot Results") + ylab("Distance")
p
```

The red shots look somewhat above the blue shots, but the shot points seem to be layered. Here's the plot with points shaped differently for different archers:

```{r, echo = FALSE}

p <- ggplot(bowData1, aes(Location, Distance_)) + 
  geom_point(aes(shape = Name_, colour = Bow_), size = 3) + 
  ggtitle("Bird's-Eye of Shot Results") + ylab("Distance")
p
```

It's now apparent that the red shots are usually higher than the green shots, and the shots cluster around distinct locations that depend on the marksman. Including marksman terms in the model allows for estimation of the noise variance around the *marksman* centers, rather than the overall center. This is beneficial from (at least) two standpoints:

1. **Interpretation**: the variance due to archer skill is clearly not random error, so a model that does not account for the marksman will give an inaccurate estimate of the true per-shot variance.
2. **Estimation of $\tau$**: we are better able to "see" the effect of the Southwood bow when we separate the shots by marksman.

After cooling down a little, Jaime realized that, despite not achieving the result he wanted, his findings could be useful to the Lannister army. He decided to run a larger experiment with 50 archers to solidify the results. Here was the outcome:

```{r}
lm2 <- lm(Distance_ ~ Bow_ + Name_, data = JaimeExp2$Data)
summary(lm2)
```

Having disregarded much of his scientific education, Jaime felt quite overwhelmed with this massive list of parameter estimates. In particular, he was confused by the few archers without a statistically significant estimate. Should he re-run the experiment without them? (Note, the standard errors for the archer effect estimates are the same because they all fired the same number of shots.)

This time, Cersei was hanging around the training grounds. Overhearing Jaime, she decided to step in. "Jaime, don't trouble yourself with those worrisome parameter estimates for the archers. I looked at your charts from the first experiment. It is certainly proper to account for archers in the model, but the only value we care about is the *variance* of their skills." Later that afternoon she developed Westeros's first Linear Mixed Effects model. In this model, archer effects are considered to be random draws from a larger population.

![*"With these equations I shall secure the reputation of the Lannister name in both might and maths"*](cersei.jpg)

## The mixed-effects model and sources of randomness

Cersei's key observation is that Jaime chose 50 archers out of the large population of archers in and around King's Landing. Furthermore, he did so in a random fashion, distributing the bow test across a representative population of archers. This randomness can be incorporated in the model by treating archer effects as Normal random variables with a common, fixed variance:
\[
Y_{ijk} = \mu + \tau\mathbb{1}(i = 2) + \alpha_j + \epsilon_{ik}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\alpha_j\sim\mathcal{N}(0, \sigma^2_a)
\]
The $\alpha_j$'s are now not of interest to estimate; they exist to separate out the contribution of marksman skill to per-shot variance. This "variance component", $\sigma^2_a$, is now the archer parameter of interest.

Note that, though the $\alpha_j$'s as modeled as random variables, they do not change shot-to-shot. Mechanistically, they are still fixed features of the archer. We regard them as random only to focus on the underlying distribution of archer skill, and its effect on the predictive model.

### Random-effects vs. Bayesian randomness

**Wait, if the parameters are random, isn't this a Bayesian model?** A reasonable question. In my view, the parameters in a mixed model get their randomness from the unit (marksman) _sampling_ process, so they have *objective* randomness, because there is a real population of parameters being sampled from. In a Bayesian model, however, parameters have *subjective* randomness in the sense that their prior and posterior distributions are meant to quantify our _personal uncertainty_ about their values. 

These are distinct conceptions of randomness. In fact, it is possible to model the random effects in a mixed-effects model as, additionally, subjectively random with respect to their values (called [Bayesian Linear Mixed Models](https://www2.stat.duke.edu/courses/Fall08/sta290/Lectures/randomeffects/randomeffects.pdf)). So, we can fit either a fixed-effects _or_ a mixed-effects model, each with a fully Bayesian approach, or not. The choice to employ a mixed-effects model in the first place still exists in the Bayesian framework, and depends on all the same aspects of our modeling goals.

Look back at the full fixed-effects model we considered for the bow experiments. In the most straightforward Bayesian framework, we would specify a conjugate set of of priors distributions: Normal for $\mu$, $\tau$, and the $\alpha_j$'s, and Inverse Gamma for $\sigma^2_e$. 

For the full mixed-effects model, however, it sort of looks like we already have a prior on the $\alpha\text{'s}$. I would argue that this is an abuse of the term "prior". The Normal distribution on the $\alpha\text{'s}$ still represents the *sampling* uncertainty in the model. In our Gibbs sampler, it is used to update the $\alpha\text{'s}$, but if we store the $\alpha\text{'s}$ what we end up with should not be interpreted as a posterior distribution of a fixed parameter.

This is not just a semantic difference: in the Bayesian approach to our mixed-effects model, we would need a prior on $\sigma^2_a$, since that is the archer parameter of interest. In the Bayesian fixed-effects model, we gave the $\alpha\text{'s}$ Normal priors directly, and $\sigma^2_a$ was a fixed hyperparameter. 

But the semantic distinctions are important too. It would be inappropriate, for instance, to talk about Bayes Factors or credible intervals associated with the $\alpha\text{'s}$, since from a modeling perspective we have decided not to treat them as values to estimate or do inference on.

### When not to use a mixed-effects model
**What's special about this sampling situation? Aren't we always picking experimental units out of a larger population?** Yes, but we don't always do so randomly. Often, we care about particular units of interest that we already know about before the experiment, so we pick them directly. There's nothing random about this process. Also, if we have that sort of interest in the units, usually estimating their effects is an important goal of the analysis, in which case we should not model the effects as random.

Going back to the story on this, Jaime might care to also estimate the skills of a few archers he knows about. In this case, he'd probably hand-pick fewer archers, and have them take more shots.

As a more realistic example, consider a small school district doing a standardized test analysis on their three middle schools. There will be many, many observations from each middle school, and the district is not necessarily interested in considering the larger population of middle schools. Their aim is to build a predictive model for their particular district, and do inference on parameters for their schools only.

## Fitting the mixed-effects model

Let's fit the model to Jaime's 2nd set of experimental data:

```{r}
lme2 <- lmer(Distance_ ~ Bow_ + (1 | Name_), data = JaimeExp2$Data)
```

The switch to mixed effects modeling shifts the focus from inference on the individual archer to inference on the population of archers. This focus is important in applications from many fields, like biology (where observations may come from many organisms), economics (where observations may come from many regions or agents), or clinical trials (where observations may come from many different labs). In our example, it makes sense for Cersei to want to learn about the variance in city-wide marksman skill along with the effect of Southbows. The estimate $\hat\sigma^2_a$ gives her this:

```{r, message = FALSE}
VarCorr(lme2)
confint(lme2)[1:2, ]
```

The output above gives the estimates for $\sigma_a$ and $\sigma_e$, and the assocated confidence intervals. These parameters don't exist in a fixed-effects model.

### Using the model to choose archer

"But wait," Jaime might protest, "what if I care about the particular archer I happened to put to task? Now we know that Northwood bows are the obvious choice, how does our model help me choose which men to take on my journey? Cersei's model isn't specific enough. At least with the fixed effects model I had parameter estimates!"

Actually, a mixed effects model can rank the units (archers) in an analogous way. Once the model is fit, we can calculate the *conditional expectation* of a particular archer's effect, given their experimental data. This can operate as a skill score for the archer:
\[
\text{Score for archer }j = \mathbb{E}\left[\alpha_j | \bar y_{j\cdot}\right]
\]
Above, $\bar y_{j\cdot}$ is the $j$-th archer's average shot distance. Remember, in the model, each $\alpha_j$ is random, with mean zero. So taking expectations shouldn't seem useful, at first. However, knowledge of the experimental data biases the expectation of $\alpha_j$, depending on where the data fall relative to the overall mean. The above quantity is often taken as a "predictor" of $\alpha_j$, and archers with higher $\bar y_{j\cdot}$'s have higher predictions. 

As it turns out, these predictions are exactly proportional to archer-wise parameter estimates from the fixed-effects model. So Jaime isn't losing anything! Also, since he's planning for a journey, the "prediction" interpretation is nice.

These characteristics of mixed-effects models are part of Bayesian approach, as well. We can compute posterior conditional means for the $\alpha\text{'s}$, and examine the posterior distributions for $\mu$, $\tau$, and the variance components. The choice between mixed-effects and fixed-effects modeling has little to do with the choice between a frequentist and Bayesian approach to parameter estimation.

### What about $\tau$?
At least for vanilla linear models, parameter and standard error estimates for fixed effects in the mixed model are the same as what they would be in the full fixed-effects model fit. However, for massive data sets with lots of parameters, it's standard practice nowadays to use a penalized likelihood, like LASSO or RIDGE. As such, the authors of the Google blog post compared mixed-effects models and _penalized_ linear models, and found that the mixed-effects model had slightly higher predictive power. 

One explanation for this could be that shrinking experimental unit effect estimates isn't optimal for predictive purposes. For example, though many archer parameters in Jaime's fixed-effects model weren't significant, it was still useful to account for their un-penalized values (see the exploratory plots with just three archers). The mixed-effect model does this by implicitly retaining the archer-wise predicted parameters, but a LASSO-penalized fixed-effect model won't.

Let's see how all this plays out with a much larger data set.

# A larger-scale example

Suppose you work for a company that provides online services with accompanying ads. Your team is trying to decide between two versions of a general ad display module for a webpage. The metric for display effectiveness is the proportion of times a user interacts with ("clicks-through") the ad out of the number of times they see it ("impressions"). Higher click-through rate (CTR) is good because it means companies who pay for ad placement will pay more.

An appropriate model for this situation is a logistic regression. In this model, each user $j$ encounters the $i$-th version of the display $n_{ij}$ times, and has some probability $p_{ij}$ of clicking on some part of it each time. This $p_{ij}$ will depend on which version of the display user $j$ is currently in front of. The parameter $\tau$ will represent the fixed effect of the new display version, analogous to the Southwood bow. The $\alpha_j$'s will be each user's "clickiness" effect, and is analogous to archer skill.

In this example, let's add another simulation component generating the total number of impressions $n_{ij}$ at random from a Poisson distribution with $\lambda = 20$. Also, we need a coin flip variable which chooses the "treatment" users. Finally, I diverted a (randomly chosen) latter portion of the treatment users' impressions to the second display. 

If we assume we already know each impression count $n_{ij}$, the simulation model is:
\[
Y_{ij}\sim\text{Binomial}(p_{ij}, n_{ij}),\;\;\;\;\;\;\log\left(\frac{p_{ij}}{1 - p_{ij}}\right) = \mu + \tau\mathbb{1}(i = 2) + \alpha_j,\;\;\;\;\;\;\alpha_j\sim\text{Normal}(0, \sigma^2)
\]

```{r, echo = FALSE}
make_click_data <- function (p, # Number of people to choose 
                             mu, # Baseline logit-probability of click 
                             tau, # Effect of new display
                             sig_a, # Variance of random effects
                             pois_mean, # Mean number of impressions
                             effects = NULL) { # In case you actually want to fix effects
  
  if (is.null(effects))
    effects <- rnorm(p, 0, sig_a)
  
  # Preparing design
  treat <- rbinom(p, 1, 0.5)
  treat_expos <- rpois(p, pois_mean * 0.5) + 1
  null_expos <- rpois(p, pois_mean * (1 - 0.5)) + 1
  id <- 1:p
  expos <- treat_expos + null_expos
  expos <- c(expos[!treat == 1], null_expos[treat == 1], treat_expos[treat == 1])
  id <- c(id[!treat == 1], rep(id[treat == 1], 2))
  treat <- c(treat[!treat == 1], rep(0, sum(treat)), rep(1, sum(treat)))
  means <- mu + treat * tau + effects[id]
  probs <- exp(means) / (1 + exp(means))
  
  # Getting response and making data matrix
  Y <- rbinom(length(probs), expos, probs)
  dataMat <- data.frame("clicks" = Y,
                        "expos" = expos,
                        "display" = treat,
                        "id" = as.factor(id))
  
  return(list("Data" = dataMat,
              "Effects" = effects))
  
}

# Make simulated data
set.seed(1)
CTR_Exp1 <- make_click_data(p = 1e3,
                            mu = -4.5,
                            tau = 0.5,
                            sig_a = 5,
                            pois_mean = 20)
```

I generated data from 1,000 users with the following parameters:

| Parameter      | Value |
|:---------------|---------|
|  $\tau$        |    0.5   |
|  $\mu$         |    -4.5  |
|  $\sigma$      |     5    |

Here's a sample of the data:
```{r, echo = FALSE}
CTRdata <- CTR_Exp1$Data
display_data <- head(CTR_Exp1$Data[sample(nrow(CTR_Exp1$Data)), ], 10)
display_data$display <- as.numeric(display_data$display) + 1
rownames(display_data) <- NULL
print(display_data)
```

Note that the data is quite sparse, in the sense that users rarely click on the display overall. This is due to the low setting of the parameter $\mu$, which is realistic due to things like [ads blindness](https://en.wikipedia.org/wiki/Banner_blindness).

We can fit a logistic mixed-effect regression model using `glmer` from the **R** package `lme4`, which is a flexible function for fitting many general linear mixed-models (GLMMs).

The format of Binomial data in **R** is always important to consider. Somehow, the function you use must know both the response and the number of trials. For `glmer` (and `glm`, the fixed-effects version), we enter the exposure in the `weights` argument, and the response must be in proportion format. Here's the setup and function call:

```{r}
# Changing the counts to proportions
CTRdata$clicks <- CTRdata$clicks / CTRdata$expos

# Analysis of the data
CTR_lme1 <- glmer(clicks ~ display + (1 | id), 
                  weights = expos,
                  data = CTRdata, 
                  family = binomial, 
                  control = glmerControl(optimizer = "bobyqa"),
                  nAGQ = 10)
```

The final two arguments are set on recommendation from [this detailed and helpful guide to Binomial GLMMs](http://www.ats.ucla.edu/stat/r/dae/melogit.htm) in **R**. They have to do with some particulars of the model fitting algorithm, considerations beyond the scope of this post. Here's the model fit summary:

```{r}
summary(CTR_lme1)
```

The p-value for the display effect is orders of magnitude smaller than needed for a usual declaration of significance. This is both surprising and not surprising. It is surprising because the true display effect tau $\tau$ was just 10% of the population standard deviation of the user population effect. This means that even at the *mean* level of the model, the display-efficacy signal is being dominated by something completely random and 10x stronger. But it is also not surprising since I simulated so much data: 10,000 users with 20 exposures (on average) is 200,000 data points.

In a logistic model, [a linear change on the logit scale is the same change in the log-odds ratio](https://en.wikipedia.org/wiki/Logit). So, we can say that our estimated change in odds of a display click induced by the display is 100% * $\exp(\hat\tau)$. We can also map the upper and lower confidence bounds on $\hat\tau$ to that scale. Doing this for all fixed effects, we get:

```{r, eval = TRUE, message = FALSE}
# Extracting estimated fixed effects
fixef_hat <- fixef(CTR_lme1)
# Extracting estimated population sd:
siga_hat <- attr(VarCorr(CTR_lme1)[[1]], "stddev")
# Extracting tau confidence bounds from model
up_low <- confint(CTR_lme1)

# Making CI mat
full_mat <- cbind("Estimate" = c(fixef_hat, siga_hat), up_low[c(2:3, 1), ])
rownames(full_mat) <- c("Intercept", "Tau", "sig_a")
print(exp(full_mat) * 100, digits = 4)
```

The new display causes an estimated change in click odds of about 167%. Considering that $\exp(0.5) \approx 1.65$, this is not too far from where I set the true effect. The interpretation of the $\mu$ estimate is that the baseline click odds are (with high confidence) less than 1% of those of getting heads on a fair coin flip. The $\sigma_a$ estimate means that user "clickiness" variance is about 100x larger than the display effect, on the log-odds scale. The large amount of data in this simulation means we can still detect the positive display effect.

### Accuracy and speed of the mixed effects model

This last section compares the performance of the Binomial GLMM to that of standard fixed-effects models, with respect to both predictive potential and compuation time.

As mentioned just before the CTR example, a common addition to large-scale fixed-effect regression modeling is a LASSO penalty. Roughly, the LASSO penalty zeros out user coefficients for users with effects not significantly different from the mean user effect. Fitting a LASSO is a little tricky in **R** if you have multi-level factor variables, especially if one of the variables has many, many levels (like our "user" variable). In case you're interested in the best way to do this, I'll print this chunk of code:

```{r, eval = TRUE}
suppressPackageStartupMessages(library(glmnet))
id.matrix <- sparse.model.matrix(~ CTRdata$id - 1)
Sparse.Data <- cbind(id.matrix, CTRdata$display)
weights <- CTRdata$expos
nclicks <- CTRdata$clicks * weights
y <- unname(cbind(weights - nclicks, nclicks))
set.seed(12345)
CTR_lasso <- cv.glmnet(Sparse.Data, y, family = "binomial")
```

I'll also fit two other fixed-effects models: a Ridge regression, which uses another form of parameter penalization, and a straight-up fixed-effect logistic model.

```{r, eval = TRUE}
set.seed(12345)
CTR_ridge <- cv.glmnet(Sparse.Data, y, family = "binomial", alpha = 0)
CTR_glm <- glm(y[ , 2:1] ~ display + id, data = CTRdata, family = "binomial")
```

The $\lambda$ regularization parameter for the Ridge and LASSO models were chosen by 10-fold cross-validation, as is default for the `cv` function. Here are the effect estimates for each of these models:

```{r, eval = TRUE, echo = FALSE, message = FALSE}
effect_estimates <- c(tail(as.numeric(coef(CTR_lasso)), 1),
                      tail(as.numeric(coef(CTR_ridge)), 1),
                      head(as.numeric(coef(CTR_glm)), 2)[2])
names(effect_estimates) <- c("LASSO", "Ridge", "GLM")
print(effect_estimates)
```

The true display effect is 0.5, so the effect of Ridge and LASSO regularization is apparent. Though Ridge and LASSO have their uses, at least in this case they're preventing an interpretable estimate of display effect. Since the logistic is a full model fit, we should not be surprised that its point estimate for $\tau$ is close to the truth.

How do the predictive powers of these approaches compare? Let's generate 50 "future" data sets from the same population of users. For each new data set, we'll predict the logit means using the fitted model from the original data. To compare the prediction accuracies of the approaches, we'll calculate the mean squared prediction error^[1]. Note that, for the future data sets, it is possible for users to be assigned to Treatment when in the original data set they were Control, and vice-versa. This provides some nice heterogenity in this comparative study. The following are the means and standard errors of the methods' MSPEs:
```{r, eval = TRUE, echo = FALSE, message = FALSE}
user_effects <- CTR_Exp1$Effects
nsims <- 50
MSEP_mat <- matrix(0, 4, nsims)
rownames(MSEP_mat) <- c("GLMM", "LASSO", "Ridge", "GLM")
for (i in 1:nsims) {
  
  # Generating data
  new_CTR <- make_click_data(p = 1e3, 
                             mu = -4.5,
                             tau = 0.5,
                             sig_a = 5,
                             pois_mean = 20,
                             effects = user_effects)
  
  # Prepping LASSO data
  new_id.matrix <- sparse.model.matrix(~ new_CTR$Data$id - 1)
  new_Sparse.Data <- cBind(new_id.matrix, new_CTR$Data$display)
  
  # Getting y data
  new_weights <- new_CTR$Data$expos
  new_nclicks <- new_CTR$Data$clicks
  y_new <- unname(cbind(new_weights - new_nclicks, new_nclicks))
  
  calc_MSEP <- function (pred) {
    err0 <- pred^2 * y_new[ , 1]
    err1 <- (1 - pred)^2 * y_new[ , 2]
    return((sum(err0) + sum(err1)) / sum(new_weights))
  }
  
  # Calculating prediction logit means
  lme_pred <- predict(CTR_lme1, newdata = new_CTR$Data)
  lasso_pred <- predict(CTR_lasso, newx = new_Sparse.Data)
  ridge_pred <- predict(CTR_ridge, newx = new_Sparse.Data)
  glm_pred <- predict(CTR_glm, newdata = new_CTR$Data)
  
  # Calculating prediction probs
  lme_pred_probs <- exp(lme_pred) / (1 + exp(lme_pred))
  lasso_pred_probs <- exp(lasso_pred) / (1 + exp(lasso_pred))
  ridge_pred_probs <- exp(ridge_pred) / (1 + exp(ridge_pred))
  glm_pred_probs <- exp(glm_pred) / (1 + exp(glm_pred))
  
  # Calculating prediction probs
  prob_mat <- cbind(exp(lme_pred) / (1 + exp(lme_pred)),
                    exp(lasso_pred) / (1 + exp(lasso_pred)),
                    exp(ridge_pred) / (1 + exp(ridge_pred)),
                    exp(glm_pred) / (1 + exp(glm_pred)))
  
  MSEP_mat[ , i] <- unname(apply(prob_mat, 2, calc_MSEP))
  
}
```
```{r}
# MSPE means
apply(MSEP_mat, 1, mean)
# MSPE standard errors
apply(MSEP_mat, 1, sd)
```

At least for this number of users, the difference between methods appears vast. Let's explore the MSPE for varying numbers of users. I ran the following experiment for a range of user sample sizes:

1. Sample the desired number of users from the population and generate data
2. Fit the GLMM, GLM, LASSO, and Ridge models to the data
3. Generate 50 new data sets from the same originally chosen users
4. Calculate and store MSPE for each data set, for each method
    
These were the results:

```{r, eval = TRUE, echo = FALSE, message = FALSE, fig.width=12}
require(microbenchmark)

ps <- seq(100, 2000, 100)
nsims <- 50

mean_MSEP <- matrix(0, 4, 20)
rownames(mean_MSEP) <- c("GLMM", "LASSO", "Ridge", "GLM")
sd_MSEP <- mean_MSEP
times <- mean_MSEP

for (k in 1:20) {
  
  #cat("Doing p =", ps[k], "\n")
  
  set.seed(1)
  CTR_Exp1 <- make_click_data(p = ps[k],
                              mu = -4.5,
                              tau = 0.5,
                              sig_a = 5,
                              pois_mean = 20)
  
  # Changing the counts to proportions
  CTR_Exp1$Data$clicks <- CTR_Exp1$Data$clicks / CTR_Exp1$Data$expos
  
  # Fitting LME
  timer <- get_nanotime()
  CTR_lme1 <- glmer(clicks ~ display + (1 | id), 
                    weights = expos,
                    data = CTR_Exp1$Data, 
                    family = binomial, 
                    control = glmerControl(optimizer = "bobyqa"),
                    nAGQ = 10)
  times["GLMM", k] <- get_nanotime() - timer
  
  timer <- get_nanotime()
  # Fitting LASSO
  library(glmnet)
  id.matrix <- sparse.model.matrix(~ CTR_Exp1$Data$id - 1)
  Sparse.Data <- cBind(id.matrix, CTR_Exp1$Data$display)
  weights <- CTR_Exp1$Data$expos
  nclicks <- CTR_Exp1$Data$clicks * weights
  y <- unname(cbind(weights - nclicks, nclicks))
  set.seed(12345)
  
  CTR_lasso <- cv.glmnet(Sparse.Data, y, family = "binomial")
  times["LASSO", k] <- get_nanotime() - timer
  
  # Fitting Ridge and GLM
  set.seed(12345)
  timer <- get_nanotime()
  CTR_ridge <- cv.glmnet(Sparse.Data, y, family = "binomial", alpha = 0)
  times["Ridge", k] <- get_nanotime() - timer
  timer <- get_nanotime()
  CTR_glm <- glm(y[ , 2:1] ~ display + id, data = CTR_Exp1$Data, family = "binomial")
  times["GLM", k] <- get_nanotime() - timer
  
  # MSEP storage unit
  user_effects <- CTR_Exp1$Effects
  nsims <- 50
  MSEP_mat <- matrix(0, 4, nsims)
  rownames(MSEP_mat) <- c("GLMM", "LASSO", "Ridge", "GLM")
  
  for (i in 1:nsims) {
    
    # Generating data
    set.seed(i)
    new_CTR <- make_click_data(p = ps[k], 
                               mu = -4.5,
                               tau = 0.5,
                               sig_a = 5,
                               pois_mean = 20,
                               effects = user_effects)
    
    # Prepping LASSO data
    new_id.matrix <- sparse.model.matrix(~ new_CTR$Data$id - 1)
    new_Sparse.Data <- cBind(new_id.matrix, new_CTR$Data$display)
    
    # Getting y data
    new_weights <- new_CTR$Data$expos
    new_nclicks <- new_CTR$Data$clicks
    y_new <- unname(cbind(new_weights - new_nclicks, new_nclicks))
    
    calc_MSEP <- function (pred) {
      err0 <- pred^2 * y_new[ , 1]
      err1 <- (1 - pred)^2 * y_new[ , 2]
      return((sum(err0) + sum(err1)) / sum(new_weights))
    }
    
    # Calculating prediction logit means
    lme_pred <- predict(CTR_lme1, newdata = new_CTR$Data)
    lasso_pred <- predict(CTR_lasso, newx = new_Sparse.Data)
    ridge_pred <- predict(CTR_ridge, newx = new_Sparse.Data)
    glm_pred <- predict(CTR_glm, newdata = new_CTR$Data)
    
    # Calculating prediction probs
    prob_mat <- cbind(exp(lme_pred) / (1 + exp(lme_pred)),
                      exp(lasso_pred) / (1 + exp(lasso_pred)),
                      exp(ridge_pred) / (1 + exp(ridge_pred)),
                      exp(glm_pred) / (1 + exp(glm_pred)))
    
    MSEP_mat[ , i] <- unname(apply(prob_mat, 2, calc_MSEP))
    
  }
  
  mean_MSEP[ , k] <- apply(MSEP_mat, 1, mean)
  sd_MSEP[ , k] <- apply(MSEP_mat, 1, sd)
  
}


group_MSEP <- rownames(mean_MSEP)[as.vector(row(mean_MSEP))]
p_MSEP <- as.vector(col(mean_MSEP))
p_MSEP <- ps[p_MSEP]
df <- data.frame("MSPE" = as.vector(mean_MSEP),
                 "Number of Users" = p_MSEP,
                 "se" = as.vector(sd_MSEP),
                 "Method" = group_MSEP)
limits <- aes(ymax = MSPE + se, ymin = MSPE - se)

p <- ggplot(df, aes(colour = Method, y = MSPE, x = Number.of.Users))
p1 <- p + geom_point() + geom_line(aes(group = Method)) + geom_errorbar(limits, width = 25) + 
  ggtitle("Mean Squared Prediction Error vs. # of Users")
time_df <- data.frame("Time" = log10(as.vector(times)),
                      "Number of Users" = p_MSEP,
                      "Method" = group_MSEP)
p2 <- ggplot(time_df, aes(colour = Method, y = Time, x = Number.of.Users))
p2 <- p2 + geom_point() + geom_line(aes(group = Method)) + 
  ggtitle("Fitting Runtime vs. # of Users")
grid.arrange(p1, p2, ncol = 2, widths = unit(c(15, 15), c("cm")))
```

Some conclusions:

1. The LASSO and Ridge models are worse than the GLM and GLMM models. Possibly, the model parsimony provided by the former methods is actually harmful in this setting. This result possibly reflects the same phenomenon at play in the Google blog post.

2. The MSPEs of the GLM and GLMM fits are nearly identical. This should not be surprising, since the model matrix equations are essentially the same.

3. While GLM and GLMM fits are identical, we seem to be gaining something computationally by fitting a mixed-effects model. This is probably only due to the particular **R** packages involved. Specifically, I think the fact that the GLM estimates come with standard errors is the main bottleneck. If we just cared about prediction, there is probably an equally fast GLM implementation. That being said, the choice to disregard user effects as parameters of interest provided the additional benefit of a faster off-the-shelf solution.

# Summary
In the first example, the Lannister family helped demonstrate dealing with multiple experimental units. This is a classical statistical concept that is still extremely relevant in many present-day applications. When we care to estimate the variance of the unit effect population, but not the effects themselves, mixed effects models are a great choice. 

Parameter randomness in mixed effects models has a different interpretation than parameter randomness in Bayesian models. In fact, you can take any combination of a (fixed-effect/mixed-effect, Bayesian/frequentist) approach to modeling parametric data.

In a realistic simulation setting with large numbers of experimental units, a mixed-effect approach out-performed some industry-standard fixed-effect approaches with respect to prediction error on future data from the same simulation procedure. Cool!

### Caveats:
For the fixed-effect models, there might be better rules-of-thumb or different regularization techniques that would make more sense for situations like the CTR example. Maybe these would improve their performance, but I'm not sure. The results shown are from the most straightforward off-the-shelf implementations for some of the most common regularization approaches.

**Wait, you work at Google, why are you responding to one of their blog posts on a personal blog?** I wrote this post before I got the job (almost a year before my first day), and published it on my old webpage. I recently completely revamped my website and blogging workflow (everything uses [blogdown](https://bookdown.org/yihui/blogdown) now), so I'm using this as an easy "first" post. As mentioned at beginning, I just tweaked the writing style; the analysis is unchanged. I think it's still a good reference for these very general methods, and I've gone back to it a few times myself!

### Further reading and references:
1. http://glmm.wikidot.com/faq
2. http://datascienceplus.com/introduction-to-bootstrap-with-applications-to-mixed-effect-models
3. http://www.ats.ucla.edu/stat/r/dae/melogit.htm
4. Variance Components (Searle, Casella, and McCulloch, 1992)
5. Generalized Linear Models, 2nd Edition (McCullagh and Nelder, 1989)

### Code examples:

To make the CTR simulation data:
```{r, eval = FALSE, echo = TRUE}
make_click_data <- function (p, # Number of people to choose 
                             mu, # Baseline logit-probability of click 
                             tau, # Effect of new display
                             sig_a, # Variance of random effects
                             pois_mean, # Mean number of impressions
                             effects = NULL) { # In case you actually want to fix effects
  
  if (is.null(effects))
    effects <- rnorm(p, 0, sig_a)
  
  # Preparing design
  treat <- rbinom(p, 1, 0.5)
  treat_expos <- rpois(p, pois_mean * 0.5) + 1
  null_expos <- rpois(p, pois_mean * (1 - 0.5)) + 1
  id <- 1:p
  expos <- treat_expos + null_expos
  expos <- c(expos[!treat == 1], null_expos[treat == 1], treat_expos[treat == 1])
  id <- c(id[!treat == 1], rep(id[treat == 1], 2))
  treat <- c(treat[!treat == 1], rep(0, sum(treat)), rep(1, sum(treat)))
  means <- mu + treat * tau + effects[id]
  probs <- exp(means) / (1 + exp(means))
  
  # Getting response and making data matrix
  Y <- rbinom(length(probs), expos, probs)
  dataMat <- data.frame("clicks" = Y,
                        "expos" = expos,
                        "display" = treat,
                        "id" = as.factor(id))
  
  return(list("Data" = dataMat,
              "Effects" = effects))
  
}

# Make simulated data
set.seed(1)
CTR_Exp1 <- make_click_data(p = 1e3,
                            mu = -4.5,
                            tau = 0.5,
                            sig_a = 5,
                            pois_mean = 20)
```

To calculate MSPE of the methods over many repetitions of the data from the original simulation model:
```{r, eval = FALSE, echo = TRUE}
user_effects <- CTR_Exp1$Effects
nsims <- 50
MSEP_mat <- matrix(0, 4, nsims)
rownames(MSEP_mat) <- c("GLMM", "LASSO", "Ridge", "GLM")
for (i in 1:nsims) {
  
  # Generating data
  new_CTR <- make_click_data(p = 1e3, 
                             mu = -4.5,
                             tau = 0.5,
                             sig_a = 5,
                             pois_mean = 20,
                             effects = user_effects)
  
  # Prepping LASSO data
  new_id.matrix <- sparse.model.matrix(~ new_CTR$Data$id - 1)
  new_Sparse.Data <- cBind(new_id.matrix, new_CTR$Data$display)
  
  # Getting y data
  new_weights <- new_CTR$Data$expos
  new_nclicks <- new_CTR$Data$clicks
  y_new <- unname(cbind(new_weights - new_nclicks, new_nclicks))
  
  calc_MSEP <- function (pred) {
    err0 <- pred^2 * y_new[ , 1]
    err1 <- (1 - pred)^2 * y_new[ , 2]
    return((sum(err0) + sum(err1)) / sum(new_weights))
  }
  
  # Calculating prediction logit means
  lme_pred <- predict(CTR_lme1, newdata = new_CTR$Data)
  lasso_pred <- predict(CTR_lasso, newx = new_Sparse.Data)
  ridge_pred <- predict(CTR_ridge, newx = new_Sparse.Data)
  glm_pred <- predict(CTR_glm, newdata = new_CTR$Data)
  
  # Calculating prediction probs
  lme_pred_probs <- exp(lme_pred) / (1 + exp(lme_pred))
  lasso_pred_probs <- exp(lasso_pred) / (1 + exp(lasso_pred))
  ridge_pred_probs <- exp(ridge_pred) / (1 + exp(ridge_pred))
  glm_pred_probs <- exp(glm_pred) / (1 + exp(glm_pred))
  
  # Calculating prediction probs
  prob_mat <- cbind(exp(lme_pred) / (1 + exp(lme_pred)),
                    exp(lasso_pred) / (1 + exp(lasso_pred)),
                    exp(ridge_pred) / (1 + exp(ridge_pred)),
                    exp(glm_pred) / (1 + exp(glm_pred)))
  
  MSEP_mat[ , i] <- unname(apply(prob_mat, 2, calc_MSEP))
  
}
```

[^1] The MSPE in this setting is defined as follows: Let $\hat\mu_{ij}$ be the model-predicted logit-mean for that user-display combination. Let $\hat p_{ij} = \frac{\exp\{\hat\mu_{ij}\}}{1 + \exp\{\hat\mu_{ij}\}}$, which is the model-predicted probability of the $j$-th user interacting with display version $i$. Let $y_{ijk}^\ast$ be the $k$-th new data point from the $j$-th user seeing display version $i$. Let $n^\ast_{ij}$ be the number of times the $j$-th user saw display $i$, and define $N^\ast:=\sum_{ij}n^\ast_{ij}$. Then:
\[
\text{MSPE} := \frac{1}{N^\ast}\sum_{ij}\sum_k(y^\ast_{ijk} - \hat p_{ij})^2
\]


